from OpenSSL.crypto import	( X509Extension
							, X509
							, dump_privatekey
							, dump_certificate
							, load_certificate
							, load_privatekey
							, PKey
							, TYPE_RSA
							, X509Req
							)
from OpenSSL.SSL import FILETYPE_PEM
from tempfile import gettempdir
from os import path, listdir

class CertificateAuthority(object):
	def __init__(self, ca_file='ca.pem', cache_dir=gettempdir()):
		self.ca_file = ca_file
		self.cache_dir = cache_dir
		self._serial = self._get_serial()
		if not path.exists(ca_file):
			print "Certificate file '%s' does not yet exist, creating it..." % ca_file
			self._generate_ca()
		else:
			self._read_ca(ca_file)
	def _get_serial(self):
		"""
		Returns CURRENT serial number, generated by taking the max of the
		serial numbers of all already-existing certificates in the temp
		folder. This is incremented by 1 when calling self.serial().
		"""
		s = 1
		for c in filter(lambda x: x.startswith('.pymp_'), listdir(self.cache_dir)):
			c = load_certificate(FILETYPE_PEM, open(path.sep.join([self.cache_dir, c])).read())
			sc = c.get_serial_number()
			if sc > s:
				s = sc
			del c
		return s
	@property
	def serial(self):
		"""Incrementing getter."""
		self._serial += 1
		return self._serial
	def _generate_ca(self):
		"""
		To be run if we don't have a CA file for self.read_ca().
		Generates a private key, generates a certificate, signs our own
		certificate, then writes it out to the ca_file for use next time.
		"""
		# Generate key
		self.key = self._make_private_key()
		# Generate certificate
		self.cert = self._generate_ca_given_key(self.key)
		# write out to file
		self._write_cert(self.ca_file, self.key, self.cert)
	def _generate_ca_given_key(self, key):
		cert = X509()
		cert.set_version(3)
		cert.set_serial_number(1)
		cert.get_subject().CN = 'ca.mitm.com'
		cert.gmtime_adj_notBefore(0)
		cert.gmtime_adj_notAfter(315360000)
		cert.set_issuer(cert.get_subject())
		cert.set_pubkey(self.key)
		cert.add_extensions([
			X509Extension("basicConstraints", True, "CA:TRUE, pathlen:0"),
			X509Extension("keyUsage", True, "keyCertSign, cRLSign"),
			X509Extension("subjectKeyIdentifier", False, "hash", subject=cert),
			])
		cert.sign(self.key, "sha1")
		return cert
	def _read_ca(self, file):
		"""Loads certificate and key for our CA from file."""
		self.key = load_privatekey(FILETYPE_PEM, open(file).read())
		self.cert = load_certificate(FILETYPE_PEM, open(file).read())
	def __getitem__(self, cn):
		"""
		Returns path to certificate for given cn. Creates it if it doesn't
		already exist.
		"""
		# get path to temp file where we'll store our certificate
		cnp = path.sep.join([self.cache_dir, '.pymp_%s.pem' % cn])
		# if we don't already have this certificate, create it and write out to the file.
		if not path.exists(cnp):
			self._make_certificate(cn, cnp)
		return cnp
	def _make_certificate(self, cn, cnp):
		"""
		Generate private key, generate certificate signing request, sign it
		using our key, and write out to file.
		Only call this if the file doesn't yet exist.
		"""
		key = self._make_private_key()
		# generate CSR (certificate signing request)
		req = X509Req()
		req.get_subject().CN = cn
		req.set_pubkey(key)
		# sign CSR (certificate signing request) and get certificate
		req.sign(key, 'sha1')
		cert = self._sign_csr(key, req)
		# dump out key and certificate to file
		self._write_cert(cnp, key, cert)
	def _sign_csr(self, key, req):
		cert = X509()
		cert.set_subject(req.get_subject())
		cert.set_serial_number(self.serial)
		cert.gmtime_adj_notBefore(0)
		cert.gmtime_adj_notAfter(31536000)
		cert.set_issuer(self.cert.get_subject())
		cert.set_pubkey(req.get_pubkey())
		cert.sign(self.key, 'sha1')
		return cert
	def _write_cert(self, certpath, key, cert):
		"""Writes private key and certificate to given file."""
		with open(certpath, 'wb+') as f:
			f.write(dump_privatekey(FILETYPE_PEM, key))
			f.write(dump_certificate(FILETYPE_PEM, cert))
	def _make_private_key(self):
		key = PKey()
		key.generate_key(TYPE_RSA, 2048)
		return key

if __name__ == "__main__":
	print "This file was not intended to be run standalone."
	print "It exports a CertificateAuthority class for use in an intercepting proxy."
